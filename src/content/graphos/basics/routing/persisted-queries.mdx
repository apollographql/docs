---
title: Persisted queries with GraphOS Enterprise
description: Reject unrecognized operations and minimize request latency
---

<blockquote>

**This feature is available only with a [GraphOS Enterprise plan](/graphos/enterprise/).** It is currently in [preview](/resources/product-launch-stages#preview).

If your organization _doesn't_ currently have an Enterprise plan, you can test out this functionality by signing up for a free [Enterprise trial](/graphos/org/plans/#enterprise-trials).

</blockquote>

With [GraphOS Enterprise](../enterprise/), you can maintain a **persisted query list** (or **PQL**) for your supergraph's self-hosted router. This list should contain all of the known GraphQL operations that all of your app clients execute against your router:

```mermaid
graph LR;

  webClient("Web<br/>Client");
  androidClient("Android<br/>Client");


  subgraph "GraphOS"
  pql[[Persisted<br/>Query List]];
  end
  
  subgraph "Your backend"
  router(["Apollo<br/>Router"]);
  end

  webClient & androidClient --->|Publishes<br/>operations|pql
  router -.->|Fetches PQL<br/>at runtime|pql
```

## Benefits

Your router can use its PQL to **protect your supergraph** and **speed up your clients**:

- If you enable **operation safelisting**, your router _rejects_ any incoming operations that aren't in its PQL.
    - This helps block requests from unauthorized clients.
- Client apps can execute an operation by providing its PQL-specified ID, _instead of_ providing its full operation string.
    - For very large operation strings, this can dramatically reduce latency and bandwidth usage.
    - Your router can even _require_ that clients provide operations this way and _reject_ full query strings (even query strings that are present in the PQL).

## Differences from APQ

The Apollo Router also supports a related feature called [automatic persisted queries](/router/configuration/in-memory-caching#caching-automatic-persisted-queries-apq), or APQ. With APQ, clients can execute a GraphQL operation by sending the _hash_ of its operation string, instead of sending the full string.

**Compared to GraphOS persisted queries, APQ has the following limitations:**

- APQ doesn't provide safelisting capabilities, because the router populates its APQ cache over time with _any_ operations it receives.
    - **With GraphOS persisted queries,** clients pre-publish their operations to GraphOS. Your router fetches its PQL on startup, enabling it to reject operations that aren't present in the PQL.

- With APQ, your router must receive any given operation string from a client at least once, in order to cache it.
    - **With GraphOS persisted queries,** your router fetches its full PQL from GraphOS on startup, which means clients can _always_ execute operations by their PQL-specified ID.

If you _only_ want to improve request latency and bandwidth usage, APQ probably addresses your use case. If you _also_ want to secure your supergraph with operation safelisting, you should use GraphOS persisted queries.

## Setup

### 0. Prerequisites

Before you get started with GraphOS persisted queries, do all of the following:

1. Update your Apollo Router instances to version `1.25.0` or later. [Download the latest version.](../quickstart/)
    - Previous versions of the Apollo Router don't support configuration for GraphOS persisted queries.
2. Make sure your router instances are [connected to your GraphOS Enterprise organization](/router/enterprise-features/#enabling-enterprise-features).
3. Update your version of the Rover CLI to `0.15.0` or later. [Download the latest version.](/rover/getting-started/)
    - Previous versions of Rover don't support publishing operations to a PQL.


### 1. Create a persisted query list (PQL)

To use persisted queries, you first create a **persisted query list** (**PQL**) in GraphOS Studio. Each PQL is associated with a single graph in GraphOS. You can link a single PQL to any number of different variants of that graph.

1. From your organization's Graphs page in [GraphOS Studio](https://studio.apollographql.com/?referrer=docs-content), open the PQL page for a particular graph by clicking its PQL button:

  <img
    className="screenshot"
    alt="The persisted query list button in the Studio graph list"
    src="../../img/pql-button.jpg"
  />

2. From the PQL page:

    - If you haven't created any PQLs yet, click **Create a Persisted Query List**.
    - If you already have at least one PQL, click **New List** in the upper right.

  The following dialog appears:

  <img
    className="screenshot"
    alt="The first step of the PQL creation dialog in GraphOS studio"
    src="../../img/pql-dialog-create.jpg"
    width="450"
  />

3. Provide a name and (optional) description for your PQL, then click **Create**.

    - At this point, your empty PQL has been created. The remaining dialog steps help with additional setup.

4. The second dialog step (**Link**) enables you to link your new PQL to one existing variant of your graph.

    - You can optionally **Skip** this step and link variants later (covered in the next step).
    
5. The third dialog step (**Publish**) displays your new PQL's unique ID, along with an example Rover CLI command for publishing operations to the PQL.

    - For now, we'll leave the PQL empty. We'll publish some operations to it in a later step.

6. The fourth and final dialog step (**Configure**) displays configuration options you apply to your router to begin using your PQL. We'll cover these in a later step.

7. Click **Finish** to close the dialog. Your newly created PQL appears in the table:

    <img
      className="screenshot"
      alt="A newly created PQL in the table on the Studio PQL page"
      src="../../img/pql-table.jpg"
      width="450"
    />

### 2. Link the PQL to variants

After you create a PQL, you can link it to one or more variants of your graph. It's safe to link an empty or incomplete PQL, because your router doesn't _use_ its PQL for anything until you configure it to do so (covered in a later step).

1. From the table on your graph's PQL page, open the **‚Ä¢‚Ä¢‚Ä¢** menu under the **Actions** column for the PQL you want to link:

    <img
      className="screenshot"
      alt="The Actions menu for a PQL in Studio"
      src="../../img/pql-table-actions.jpg"
      width="250"
    />

2. Click **Link and Unlink Variants**. The following dialog appears:

    <img
      className="screenshot"
      alt="Dialog for linking PQLs to variants in Studio"
      src="../../img/pql-link-variants.jpg"
      width="500"
    />

3. Use the dropdown menu to select any variants you want to link your PQL to.

4. Click **Save**.

After you link a PQL to a variant:

1. GraphOS validates the PQL against the variant's reported operation history and flags any recent operations that aren't represented in the PQL.

2. GraphOS then uploads the PQL to Uplink, the service that delivers configuration to your router at runtime.

> As a best practice, you should link PQLs to your staging _and_ production environments.

### 3. Generate operation manifests

After you create a PQL, you can start publishing operations to it. To do _that_, you need to generate JSON **manifests** of the operations to publish. You usually generate a separate manifest for each of your client apps.

<ExpansionPanel title="See an example manifest file with two operations">

```json title="persisted-queries.json"
{  
  "format": "apollo-persisted-queries",
  "version": 1,
  "operations": [  
    {
      "id": "dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f",
      "body": "query UniversalQuery { __typename }",
      "name": "UniversalQuery",
      "type": "query" 
    },
    {
      "id": "f11e4dcb28788af2e41689bb366472084aa1aa1e1ba633c3d605279cff08ed59",
      "body": "query FragmentedQuery { post { ...PostFragment } }  fragment PostFragment on Post { id title }",
      "name": "FragmentedQuery",
      "type": "query" 
    }
  ]
}
```

</ExpansionPanel>

You can perform manifest generation in your CI/CD pipeline, enabling you to incorporate new operations automatically whenever you release a new client app version.

#### Generation methods

Apollo Client for Web and iOS each provide a mechanism for generating a manifest file from your application source. Similar mechanisms for other client libraries are in development.

> You can also build your _own_ mechanism for generating operation manifests. See the supported [manifest format](#manifest-format).

#### Keeping build and runtime operation signatures consistent

Operations that are executed against your graph at runtime must precisely match the shapes of the operations in your Persisted Queries List. By default, even whitespace must match. Apollo Client libraries can all potentially modify the operations they define in app. This means that the operations they define will be potentially different from the operations that are executed at runtime.

For example, the client libraries typically add a `__typename`  field to every object type in the operation in order to understand more information about the operation's result. It's important that these changes are reflected in the published operations as well. Otherwise, two kinds of issues may occur:

- If a client's operation is published without the added __typename and the client sends the operation's ID in its request, the server will return results that do not include the `__typename` fields that the client was expecting. This will break the client features that need to know the type information.

- If a client's operation is published without the added `__typename` and the client sends the operation as a raw GraphQL document, then if the Router is configured to reject raw GraphQL that does not match a published operation, the operation may be surprisingly rejected. (We expect the "matching" rules to be configurable here, so that this particular "unexpected extra `__typename`" case could be made to work, but this may not cover all possible client-side transformations.)

Apollo's clients use the same logic to transform operations at runtime and at build time, so that this is not a concern.

### 4. Publish operations to the PQL

After you [generate an operation manifest](#3-generate-operation-manifests), you publish it to your PQL with the [Rover CLI](/rover/):

```bash title="Example command"
rover persisted-queries publish my-graph@my-variant \
  --manifest ./persisted-query-manifest.json
```

- Replace `my-graph@my-variant` with the **graph ref** of any variant that your PQL is [linked to](#2-link-the-pql-to-variants).
    - Graph refs have the format `graph-id@variant-name`.
- For the `--manifest` option, provide the path to the manifest you want to publish.

> [See the full reference for `rover persisted-queries publish`.]()

**The above command does the following:**

1. It publishes all operations in the provided manifest file to whichever PQL is linked to the specified variant.
    - If you publish an operation with the same `id` as an existing PQL entry, the existing entry is overwritten. Overwriting a PQL entry with new details can break your clients! For more information, see [Generating IDs](#generating-ids).
    - It's always safe to publish an operation with the _exact same details_ as one that's already in the PQL.

2. It updates any _other_ variants that the PQL is applied to, so routers associated with those variants can fetch their updated PQL.

As with [generating manifests](#3-generate-operation-manifests), you can execute this command in your CI/CD pipeline to publish new operations as part of your app release process.

### 5. Configure your router

After you [publish all operations](#4-publish-operations-to-the-pql) to your PQL, you can configure your router instances to fetch and _use_ your PQL.

1. As mentioned in [Prerequisites](#0-prerequisites):
    - Make sure you're using version `1.25.0` or later of the Apollo Router.
    - Make sure your router instances are [connected to your GraphOS Enterprise organization](/router/enterprise-features/#enabling-enterprise-features), and that they're associated with a variant that your PQL is linked to.

2. Add your desired persisted query configuration to your router's [YAML config file](/router/configuration/overview/#yaml-config-file). See [Recommended configurations](#recommended-configurations) below.

3. Deploy your updated router instances.

#### Recommended configurations

Add one of the following configurations to your router's [YAML config file](/router/configuration/overview/#yaml-config-file) to enable your router to fetch and use its associated PQL. Configurations are listed in ascending order of security enforcement:

##### Performance-only (no safelisting)

If you want to use persisted queries _only_ to reduce network bandwidth and latency (_not_ for safelisting), add the following minimal configuration:

```yaml title="router.yaml"
persisted_queries:
  enabled: true
```

This enables your clients to execute operations by providing their PQL-specified ID (instead of the full query string). Your router continues to accept full query strings as well, even for operations that _don't_ appear in its PQL.

##### Safelisting (query strings allowed)

> ‚ö†Ô∏è **Before you apply this configuration,** first make sure your PQL contains _all_ of the GraphQL operations that _all active versions_ of your clients execute! If you enable safelisting _without_ ensuring this, your router will reject unpublished client operations!

With the following configuration, your router allows _only_ GraphQL operations that are present in its PQL, while rejecting all other operations:

```yaml title="router.yaml"
persisted_queries:
  enabled: true
  safelist:
    enabled: true
    freeform_graphql: 
      enabled: true
```

When executing an operation, clients can provide either its full operation string _or_ its PQL-specified ID.

##### Safelisting (PQL IDs only)

> ‚ö†Ô∏è **Do not use this configuration initially!** It requires _all_ of your clients to execute operations by providing their PQL-specified ID. See details below.

With the following configuration, your router allows _only_ GraphQL operations that are present in its PQL, _and_ it requires clients to provide PQL-specified IDs instead of full query strings:

```yaml title="router.yaml"
persisted_queries:
  enabled: true
  safelist:
    enabled: true
    freeform_graphql:
      enabled: false #highlight-line
```

### 6. Update your clients

If you've followed the above steps (create a PQ List, link it to a variant, publish operations to it, enable known operations in your router), you can start sending known operations to your router.

Start the router:

```bash
APOLLO_KEY="..." APOLLO_GRAPH_REF="..." ./router --config ./router.yaml

2023-05-11T15:32:30.684460Z  INFO Apollo Router v1.18.1 // (c) Apollo Graph, Inc. // Licensed as ELv2 (https://go.apollo.dev/elv2)
2023-05-11T15:32:30.684480Z  INFO Anonymous usage data is gathered to inform Apollo product development.  See https://go.apollo.dev/o/privacy for details.
2023-05-11T15:32:31.507085Z  INFO Health check endpoint exposed at http://127.0.0.1:8088/health
2023-05-11T15:32:31.507823Z  INFO GraphQL endpoint exposed at http://127.0.0.1:4000/ üöÄ
```

Make an APQ-style POST request:

Earlier we published the universal query with an ID of `dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f`, we can make a request like so to execute it:

```bash
curl http://localhost:4000 -X POST --json \
'{"extensions":{"persistedQuery":{"version":1,"sha256Hash":"dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f"}}}'
```


## Manifest format

<blockquote>

‚ö†Ô∏è **This manifest format is subject to change during the preview period.**

You only need to read this section if you're building your own tooling to [generate persisted query manifests](#generating-manifests).

</blockquote>

This is a file with the following minimal structure:

```json title="persisted-queries-manifest.json"
{  
  "format": "apollo-persisted-queries",
  "version": 1,
  "operations": [  
    {
      "id": "dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f",
      "body": "query UniversalQuery { __typename }",
      "name": "UniversalQuery",
      "type": "query" 
    }
  ]
}
```

Manifest properties are documented below.

### Top-level properties

<table class="field-table">
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

###### `format`

</td>
<td>

This value is currently always `apollo-persisted-queries`.

</td>
</tr>

<tr>
<td>

###### `version`

</td>
<td>

This value is currently always `1`.

</td>
</tr>

<tr>
<td>

###### `operations`

</td>
<td>

An array of objects describing the individual GraphQL operations to publish.

For details, see [Per-operation properties](#per-operation-properties).

</td>
</tr>

</tbody>
</table>

### Per-operation properties

Each entry in a [manifest's](#manifest-format) `operations` array is a JSON object that describes a single GraphQL operation to publish:

```json
{
  "id": "dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f",
  "body": "query UniversalQuery { __typename }",
  "name": "UniversalQuery",
  "type": "query" 
}
```

Each operation object has the following properties:

<table class="field-table">
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

###### `id`

</td>
<td>

The unique ID to use for the operation in your PQL.

**This value must be unique among operations in the PQL.** If you publish an operation with the same `id` as an existing operation, the new operation _overwrites_ the existing PQL entry.

**To ensure uniqueness,** tooling should generate this value based on the operation `body`. For details, see [Generating IDs](#generating-ids).

</td>
</tr>

<tr>
<td>

###### `body`

</td>
<td>

The complete query document for the operation. Includes the definition of the operation itself, along with any required fragment definitions.

</td>
</tr>

<tr>
<td>

###### `name`

</td>
<td>

The operation's name. Must match the name specified in `body`.

This value does _not_ need to be unique among operations in the PQL. Often, different clients execute slightly different operations with the same name, and those operations each require a separate entry in the PQL.

</td>
</tr>

<tr>
<td>

###### `type`

</td>
<td>

The type of GraphQL operation. Always one of the following values:

- `query`
- `mutation`
- `subscription`

</td>
</tr>

</tbody>
</table>

You define all of the operations to publish under the `operations` key, which maps persisted query IDs to operation details. The above example associates the operation: `query Universal { __typename }` to the key: `dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f`. In practice, this identifier can be any string, but it must be a unique key in your list.

`name` should be the name of the published operation. It does not need to be unique; typically a Persisted Queries List will contain multiple operations with the same name from different versions of your client. It is used to help find operations when browsing them and does not affect Router behavior.

`type` should be `"query"`, `"mutation"`, or `"subscription"`.

### Generating IDs

When generating operation identifiers, we encourage you to use a value that's derived directly from the query's details, such as the query document
s cryptographic hash. Apollo tools that extract operations use the base16 representation of the document's SHA256 hash, which is the same format used in APQs.

In almost all cases, you should not modify the operation body of a published operation. If you make changes to an existing published operation, you should publish a new operation with a new corresponding identifier. This ensures that multiple versions of a client application can work at once, providing different operation IDs to run different "versions" of the operation.

## Managing PQLs

### Modifying an existing operation

GraphOS does allow modifying the body of a published persisted query (this requires user confirmation). This functionality is not intended for modeling the evolution of a GraphQL operation over time. Instead, this supports advanced use cases like forcing legacy client versions to execute slightly different operations without needing to modify client code.

### Removing an operation from a PQL

You might occasionally need to remove an operation from a PQL. Organization members with the **Graph Admin** role can remove individual operations from a PQL in GraphOS Studio:

[ SCREENSHOT ]
