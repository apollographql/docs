---
title: Schema proposals
subtitle: Propose, review, and track schema changes before and after publication
description: Use GraphOS's native GraphQL schema management process propose, review, and track schema changes before and after publication.
---

<GraphOSEnterpriseRequired />

As your supergraph schema grows in complexity, changing it can become increasingly difficult.
The impacts of schema changes on [composition](/federation/federated-types/composition/) and client operations become harder to assess before publication.
Once schema design changes are agreed upon, ensuring they are honored later in the subgraph development lifecycle can become another challenge.

These challenges multiply when attempting to update multiple subgraph schemas simultaneously.
Schema development can stall without the clear cross-team communication needed to understand, verify, and track changes.

## Schema proposals for schema change management

**Schema proposals** provide GraphOS-native schema change management.
The centralized proposal process fosters collaboration and strengthens schema governance:

- Subgraph developers can propose changes in the context of the supergraph and use automated checks and reviewer feedback to validate them.
- Graph consumers can actively participate by commenting on, reviewing, and approving proposals.
- Graph owners and governance teams can use proposals to set standards and ensure that only approved changes are published.

This increased coordination improves design decisions and accountability, making development cycles more efficient.

## Benefits of native schema change management

Managing schema changes _directly in GraphOS Studio_ provides the following benefits:

- The proposal process **leverages GraphOS [schema checks](./schema-checks)&mdash;including [schema linting](./schema-linter)&mdash;at every step**.
  - This provides an immediate understanding of the changes' impacts on composition and client operations.
  - It also minimizes the likelihood of errors and inconsistencies.
- Editing, reviewing, and approving changes in GraphOS allows for **GraphQL-aware schema diffing**.
  - For example, if you add new fields and types in the GraphOS [proposals editor](#edit-subgraph-schemas), GraphOS diffs those additions as new fields and types, regardless of how they are formatted.
  - GraphQL-naive text diffing won't understand and diff changes if they aren't conventionally formatted.
- Centralizing the schema change process **consolidates a comprehensive audit trail** of discussions and schema changes.

## How schema proposals work

Schema proposals are [created](./propose-changes), [reviewed](./review-proposals), and [approved](./review-proposals#approved-reviews) in GraphOS Studio. After approval, the proposal is implemented &mdash;including resolver and any other supporting code changes&mdash; before being published back to GraphOS. You can [configure schema checks](./schema-checks/#proposals-checks) to ensure your organization only publishes changes that are part of an approved proposal.

Before describing the details of this proposal process, it's helpful to understand the statuses a proposal progresses through.

### Proposal statuses

<table className="field-table">
  <thead>
    <tr>
      <th>Status</th>
      <th>Automatic or <br /> manually set</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

##### Draft

</td>
<td>
Automatic at proposal creation but can be <br/> <a href="./propose-changes#change-proposal-status">manually reset</a>
</td>
<td>
Default status upon creation until the proposal is ready for review.
</td>
</tr>
<tr>
<td>

##### Open for feedback

</td>
<td><a href="./propose-changes#change-proposal-status">Manual</a></td>
<td>Signals the proposal is ready for review.
<br/><br/>
- If <a href="./configure-proposals/#default-reviewers">default reviewers</a> are configured, they become assigned for review.</td>
</tr>
<tr>
<td>

##### Approved

</td>
<td>Automatic</td>
<td>
The{' '}
<a href="./configure-proposals#required-approvals">
minimum number of reviewers
</a>{' '}
has approved the proposal.
<br/> <br/>
- If you've <a href="./configure-proposals/#require-default-reviewer-approval">required default reviewer approval</a>, at least one approval must be from a <a href="./configure-proposals/#default-reviewers">default reviewer</a>.
</td>
</tr>
<tr>
<td>

##### Implemented

</td>
<td>Automatic</td>
<td>
All the proposal's changes have been{' '}
<a href="./publishing-schemas">published</a>. <br />
<br /> - Implemented proposals cannot receive further revisions. <br /> -
Their status cannot be updated.
</td>
</tr>
<tr>
<td>

##### Closed

</td>
<td><a href="./propose-changes#change-proposal-status">Manual</a></td>
<td>
Signals the proposal is suspended or abandoned. <br />
<br /> - Closed proposals cannot receive further revisions. <br /> - You
can reopen a proposal by setting the status to <strong> Draft</strong> or <strong>Open for feedback</strong>.
</td>
</tr>
</tbody>
</table>

A proposal doesn't have to progress linearly from **Draft** to **Implemented**. It may be **Closed** before returning to **Draft** and continuing through the process.

### Proposal process

Schema proposal statuses enable the following end-to-end schema change management process:

```mermaid
graph LR
    subgraph Draft ["Proposal creation"]
    direction LR
    Creation["Start proposal"]
    DraftStatus(("Draft status"))
    Edit["Edit subgraphs, lint, <br/> save, and check changes"]
    Request["Request reviews"]
    Creation -->  DraftStatus --> Edit --> Request
    end
    class DraftStatus secondary;
    class DraftStatus CircleSize50;
```

```mermaid
graph LR
    subgraph Open4Feedback ["Proposal review"]
    direction LR
    Feedback((Open for <br/>feedback <br/> status))
    Feedback1["Receive feedback "]
    Feedback2["Address feedback "]
    Approvals["Receive<br/>minimum approvals"]
    Feedback --> Feedback1 --> Feedback2 --> Approvals
    end
    class Feedback secondary;
    class Feedback CircleSize50;
```

```mermaid
graph LR
    subgraph Approved ["Proposal implementation"]
    direction LR
    ApprovedStatus((Approved <br/> status))
    Fetch["Fetch proposal and <br> implement locally"]
    Push["Run checks on <br> local changes"]
    Check[["GraphOS <br/> schema checks"]]
    ApprovedStatus --> Fetch --> Push --> Check
    end
    class ApprovedStatus secondary;
    class ApprovedStatus CircleSize50;
    class Check tertiary;
```

```mermaid
graph LR
    subgraph Implemented ["Proposal publication"]
    direction LR
    Checks[["Schema checks <br/> pass"]]
    Publish["Publish schema <br/> to GraphOS"]
    Monitor[["GraphOS matches <br/> changes to proposals"]]
    ImplementedStatus((Implemented <br/> status))
    Checks --> Publish --> Monitor --> ImplementedStatus
    end
    class ImplementedStatus secondary;
    class ImplementedStatus CircleSize50;
    class Checks,Monitor tertiary;
```

##### Legend

```mermaid
graph TB
  Status((Proposal <br/> status))
  User["User action"]
  Automated[["Automated <br/> GraphOS action"]]
  class Status secondary;
  class Automated tertiary;
  User:::padding
  classDef padding padding-left:5em, padding-right:5em
```

## Next steps

Schema proposal default configurations let you start using them out of the box. If you want to finetune your graph's proposal process, including permissions, approval requirements, and more, check out [Configure proposals](./configure-proposals).

To learn more about each stage in the process, refer to the following articles:

- [Propose changes](./propose-changes)
- [Review proposals](./review-proposals)
- [Implement proposals](./implement-proposals) (covers both implementation and publication)


