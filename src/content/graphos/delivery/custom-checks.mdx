---
title: Run Custom Schema Checks
subtitle: Extend GraphOS schema checks with custom validations
description: Learn how to extend the GraphOS schema checks workflow by configuring custom schema checks that allow your organization to enforce unique validation rules using your own services.
---

<EnterpriseFeature linkWithAnchor="https://www.apollographql.com/pricing#delivery-pipeline" />

Your organization might need to enforce schema standards beyond the default [GraphOS linter rules](./linter-rules).
Or you may require validations that depend on external data, such as ensuring schema changes are only submitted from a specific branch in version control.

Custom schema checks extend the GraphOS schema checks workflow by letting you running custom validations like these using your own services.

## How custom checks work

Once you [configure custom checks](./custom-checks), GraphOS sends schema change information to an endpoint you specify.
Your endpoint can then perform validations and respond with any potential issues.
GraphOS Studio displays these flagged issues along with other check result details.

<img
  className="screenshot"
  src="../img/schema-checks/custom-check-result.jpg"
  alt="To-do: Schema check run showing custom check details in GraphOS Studio"
  width="700"
/>

<Note>

You can only register one endpoint, but that endpoint can perform as many different schema validations as you want.

</Note>

Custom checks run alongside other check types—like [operations and linter checks](./schema-checks#types-of-checks)—as part of every schema check run.
Like those other check types, custom checks only run [after a build check has successfully completed](schema-checks#build-checks-1).

## Configuration

Custom checks require you to set up an HTTPS endpoint that's accessible via the public internet.
You can set secret tokens to ensure that your endpoint only responds to requests sent by GraphOS.
Once you register your endpoint in GraphOS Studio, GraphOS sends it webhook notifications as POST requests.

### Set up a validation endpoint

Your validation endpoint should:

1. Be able to receive and process a POST request with a payload with [the specified JSON format](#receiving-and-processing-payloads).
1. Send a `200` response to the request.
    - When GraphOS dispatches a webhook with check information, it has a 30-second timeout to receive a `200` response.
    - If the request times out or doesn't receive a `200`, it will retry up to five times, with an exponential backoff delay starting at 5 seconds and going up to 60 seconds.
1. [Submit validation check results](#submitting-a-check-result) to the GraphOS Platform API.

Beyond these requirements, your endpoint can run any validations you choose.

#### Receiving and processing payloads

On every schema run, GraphOS sends your registered endpoint a POST request.
The request has a payload with the following shape:

<ExpansionPanel title="See example payload">

```json
{
  "eventType": "APOLLO_CUSTOM_CHECK",
  "TODO:version": "...",
  "checkStep": {
    "graphId": "string",
    "graphVariant": "string",
    "taskId": "UUID",
    "workflowId": "UUID",
    "gitContext": {
      "branch": "string",
      "commit": "string",
      "committer": "string",
      "message": "string",
      "remoteUrl": "string"
    }
  },
  "baseSchema": {
    "hash": "string",
    "subgraphs": [
      {
        "hash": "string",
        "name": "string"
      }
    ]
  },
  "proposedSchema": {
    "hash": "string",
    "subgraphs": [
      {
        "hash": "string",
        "name": "string"
      }
    ]
  }
}
```

</ExpansionPanel>

<Note>

Payloads may include additional properties in the future.

</Note>

Because schemas can be large, the payload provides schema hashes rather than full-text schemas.
Your endpoint can request the full schema contents using the [GraphOS Platform API](/graphos/platform-api/).
Using the schema contents and payload information, your endpoint can perform whatever validations you need.

Refer to [Platform API docs](https://studio.apollographql.com/public/apollo-platform/home?variant=main) for instructions on making and authenticating requests.
See the examples below for fetching schema contents by hash.

#### Fetch a single schema

To fetch a single supergraph or subgraph schema contents by hash, use the following GraphQL query on the Platform API:

```graphql
query schema($graphId: ID!, $hash: SHA256) {
  graph(id: $graphId) {
    doc(hash: $hash) {
      source
    }
  }
}
```

#### Fetch all schemas

To request all subgraphs and supergraph schema in one request, use the following GraphQL query on the Platform API:

```graphql
query schema(
  $graphId: ID!
  $supergraphHash: SHA256
  $subgraphAHash: SHA256
  $subgraphBHash: SHA256
) {
  graph(id: $graphId) {
    supergraph: doc(hash: $supergraphHash) {
      source
    }
    subgraphA: doc(hash: $subgraphAHash) {
      source
    }
    subgraphB: doc(hash: $subgraphBHash) {
      source
    }
  }
}
```

#### Submitting a check result

Once your endpoint has completed its validation, it should submit the results back to the triggering schema check run using the Platform API.
The results should include a list of violations, each with the following:

- Violation [severity level](./schema-linter/#setting-severity-levels), either `ERROR`, `WARN`, or `IGNORE`
- Name of the violated rule
- Error message

To-do: Example level, rule, message

The triggering schema check run waits for a response for ten minutes and doesn't complete until it receives it.
If ten minutes pass without a response, the schema check run is marked as failed.

#### Example check results mutation

You can execute use the following GraphQL mutation on the Platform API to submit custom check results:

```graphql
mutation SchemaCheckCallback(
  $input: CustomCheckCallbackInput!
  $name: String!
  $graphId: ID!
) {
  graph(id: $graphId) {
    id
    variant(name: $name) {
      id
      customCheckCallback(input: $input) {
        __typename
        ... on CustomCheckResult {
          violations {
            level
            message
            rule
          }
        }
        ... on PermissionError {
          message
        }
        ... on TaskError {
          message
        }
        ... on ValidationError {
          message
        }
      }
    }
  }
}
```

### Enable custom checks in Studio

Once your endpoint is ready, you need to register it in GraphOS Studio.

1. In [GraphOS Studio](https://studio.apollographql.com?referrer=docs-content), go to your graph's **Checks** page.
2. Select **Configuration** in the upper right to open the checks configuration page.
3. From the checks configuration page, open the **Custom Checks** section.
4. Toggle on the switch next to **Enable Custom Checks**.
5. Click the **Edit** button next to **Registered webhook** and enter the **Endpoint URL**.
6. Optionally, enter a **Secret Token**.

    If you enter a token, each notification HTTP request includes an `x-apollo-signature` header whose value is a [Hash Message Authentication Code (HMAC)](https://en.wikipedia.org/wiki/HMAC) generated using the token, the request body as the message, and the SHA256 hash function. The `x-apollo-signature` header has the format `sha256=<hmac-value>`.

    <ExpansionPanel title="See an example">

    Given the following inputs:

    **Secret token** (key): `your_secret_token`

    **Request body** (message):

    ```json
    {
        "to":"do"
    }
    ```

    **Hash function**: SHA256

    The `x-apollo-header` value would be `sha256=to-do`.
    </ExpansionPanel>

    Refer to this [guide from Okta](https://www.okta.com/identity-101/hmac/) to learn more about implementation and see additional resources.

You should now see your configured webhook on the configuration page, be able to send test notifications, and begin to receive events at the specified endpoint.

## Example implementation

To-do: More information on an example implementation.

Refer to the [example implementation](https://github.com/apollosolutions/custom-check-examples) for a custom check that enforces eslint rules.