---
title: Relay-style connections FAQ
id: TN0029
tags: [best practices, schema design]
---

### What are Relay-style connections?

[Relay](https://relay.dev) is an opinionated GraphQL client, and the [Connections specification](https://relay.dev/graphql/connections.htm) defines a pattern for expressing one-to-many relationships in a GraphQL schema.

```graphql
query MyPosts($cursor: String) {
  viewer {
    posts(first: 5, after: $cursor) {
      edges {
        node {
          id
          title
          content
        }
        cursor
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
}
```

<ExpansionPanel title="View the GraphQL schema for the above operation">

```graphql
type Query {
  viewer: User
}

type User {
  id: ID!
  posts(first: Int, after: String, last: Int, before: String): PostConnection!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

type PostEdge {
  node: Post
  cursor: String!
}

type Post {
  id: ID!
  title: String
  content: String
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
```

</ExpansionPanel>

It's worth noting that Facebook designed the Connections specification for their Newsfeed feature with these features in mind:

- It uses cursor-based pagination.
- It supports paging backward (with the `before` cursor) and forward (with the `after` cursor).
- Each item in the list has a cursor you can use to jump to a specific page in the middle of the list.

These features might not perfectly meet your requirements or the capabilities of your downstream data sources.

### Do I have to use Relay-style connections?

No, unless you're using the Relay client. But its popularity outside of the Relay ecosystem is worth taking advantage of:

- Many developers are familiar with the pattern.
- It encapsulates several schema design best practices.
- It's designed to be future-proof and support gradual evolution of your GraphQL schema.

### Do I even need a wrapper type for my lists?

Consider the ["Zero, One, Infinity" rule](https://en.wikipedia.org/wiki/Zero_one_infinity_rule) — can you definitively assert that your list will never require pagination or other metadata about the relationship?

Apollo recommends always using a wrapper type for lists so that you can gracefully evolve your schema without breaking existing clients.

### Do I have to implement the entire connection specification?

No, you can use a subset of the specification. This allows adding features over time to reach compliance with the specification (if necessary).

If your downstream data sources don't support paging backward, you can drop those features:

<ExpansionPanel title="An example with only forward pagination">

```graphql
query MyPosts($cursor: String) {
  viewer {
    posts(first: 5, after: $cursor) {
      edges {
        node {
          id
          title
          content
        }
        cursor
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
}
```

```graphql
type Query {
  viewer: User
}

type User {
  id: ID!
  posts(first: Int, after: String): PostConnection!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

type PostEdge {
  node: Post
  cursor: String!
}

type Post {
  id: ID!
  title: String
  content: String
}

type PageInfo {
  hasNextPage: Boolean!
  endCursor: String
}
```

</ExpansionPanel>

If your downstream data sources don't support per-node cursors, you can drop the `edges` field and use `nodes`:

<ExpansionPanel title="An example without edges">

```graphql
query MyPosts($cursor: String) {
  viewer {
    posts(first: 5, after: $cursor) {
      nodes {
        id
        title
        content
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
}
```

```graphql
type Query {
  viewer: User
}

type User {
  id: ID!
  posts(first: Int, after: String, last: Int, before: String): PostConnection!
}

type PostConnection {
  nodes: [Post!]!
  pageInfo: PageInfo!
}

type PostEdge {
  node: Post
  cursor: String!
}

type Post {
  id: ID!
  title: String
  content: String
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
```

</ExpansionPanel>

### Are there other ways to design your schema for pagination?

Yes. If your requirements or downstream capabilities don't fit the Relay-style connections spec, we recommend using a different set of conventions so that it's clear to graph consumers that they shouldn't expect to use Relay connection patterns.

Here's an example of pagination that uses page offsets and supports a UI for jumping to a specific page.

<ExpansionPanel title="An alternative to Relay-style connections">

```graphql
query MyPosts($page: Int) {
  viewer {
    posts(page: $page) {
      nodes {
        id
        title
        content
      }
      totalPages
    }
  }
}
```

```graphql
type Query {
  viewer: User
}

type User {
  id: ID!
  posts(page: Int): PostsPaginated!
}

"""
This wrapper type uses a different suffix to distinguish
it from Relay-style connection wrappers.
"""
type PostsPaginated {
  """
  Using `nodes` avoids the redundant
  `{ posts { posts { id } } }` selection set.
  """
  nodes: [Post!]!

  """
  Adding pagination metadata directly to the
  wrapper type works well.
  """
  totalPages: Int!
}

type Post {
  id: ID!
  title: String
  content: String
}
```

</ExpansionPanel>

### Can I use Relay-style connections with Apollo Federation?

Yes! You define the schema and resolvers for the connection relationship within a single subgraph so Federation has almost no ramifications on the pattern.

The one exception is the `PageInfo` type, which is commonly has a consistent defintion for all connections. You must mark it as `@shareable` to define it in multiple subgraphs.

```graphql
type PageInfo @shareable {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
```
